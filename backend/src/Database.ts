//Source code generated by AppGPT (www.appgpt.tech)

//Class to create tables and seed new database
import { DataSource } from 'typeorm';
import { DBConfiguration } from './Configuration';
import { SettingsEntity } from './db/Settings.entity';
//autogenerate imports based on resources
import { UsersEntity } from './db/Users.entity';
import { OrdersEntity } from './db/Orders.entity';
import { PaymentsEntity } from './db/Payments.entity';
import { NotesEntity } from './db/Notes.entity';
import { SellersEntity } from './db/Sellers.entity';

export class Database {
  static dbConfiguration: DBConfiguration;
  public static ds: DataSource;

  static async Initialize(dbConfiguration: DBConfiguration) {
    Database.dbConfiguration = dbConfiguration;
    let dbConfig: any = dbConfiguration as any;
    //Autogenerate entities array from resource names

    dbConfig.entities = [
      SettingsEntity,
      UsersEntity,
      OrdersEntity,
      PaymentsEntity,
      NotesEntity,
      SellersEntity,
    ];
    Database.ds = new DataSource(dbConfig);
    await Database.ds.initialize();

    //TODO: Drop all tables

    await Database.Seed();
  }
  static async Seed() {
    let data: any = {
      Users: [
        {
          UserID: 1,
          Name: 'Aarav Patel',
          Email: 'aarav.patel@example.com',
          Password: 'Aarav123!',
        },
        {
          UserID: 2,
          Name: 'Bhavika Sharma',
          Email: 'bhavika.sharma@example.com',
          Password: 'Bhavika456!',
        },
        {
          UserID: 3,
          Name: 'Chetan Kumar',
          Email: 'chetan.kumar@example.com',
          Password: 'Chetan789!',
        },
        {
          UserID: 4,
          Name: 'Divya Singh',
          Email: 'divya.singh@example.com',
          Password: 'Divya012!',
        },
        {
          UserID: 5,
          Name: 'Eshaan Gupta',
          Email: 'eshaan.gupta@example.com',
          Password: 'Eshaan345!',
        },
      ],
      Orders: [
        {
          OrderID: 1,
          UserID: 1,
          NoteDenomination: 200,
          Quantity: 5,
          TotalAmount: 1000,
          Status: 'Completed',
          Timestamp: '2023-04-01T10:00:00Z',
        },
        {
          OrderID: 2,
          UserID: 2,
          NoteDenomination: 100,
          Quantity: 10,
          TotalAmount: 1000,
          Status: 'In Progress',
          Timestamp: '2023-04-02T11:30:00Z',
        },
        {
          OrderID: 3,
          UserID: 3,
          NoteDenomination: 50,
          Quantity: 20,
          TotalAmount: 1000,
          Status: 'Pending',
          Timestamp: '2023-04-03T09:15:00Z',
        },
        {
          OrderID: 4,
          UserID: 4,
          NoteDenomination: 20,
          Quantity: 50,
          TotalAmount: 1000,
          Status: 'Completed',
          Timestamp: '2023-04-04T14:45:00Z',
        },
        {
          OrderID: 5,
          UserID: 5,
          NoteDenomination: 10,
          Quantity: 100,
          TotalAmount: 1000,
          Status: 'Completed',
          Timestamp: '2023-04-05T16:20:00Z',
        },
      ],
      Payments: [
        {
          PaymentID: 1,
          UserID: 1,
          Amount: 1050,
          PaymentMethod: 'UPI',
          TransactionID: 'TXN123456789',
          Timestamp: '2023-04-01T10:00:00Z',
        },
        {
          PaymentID: 2,
          UserID: 2,
          Amount: 2100,
          PaymentMethod: 'Card',
          TransactionID: 'TXN987654321',
          Timestamp: '2023-04-01T11:00:00Z',
        },
        {
          PaymentID: 3,
          UserID: 3,
          Amount: 525,
          PaymentMethod: 'UPI',
          TransactionID: 'TXN123432123',
          Timestamp: '2023-04-02T10:00:00Z',
        },
        {
          PaymentID: 4,
          UserID: 4,
          Amount: 1050,
          PaymentMethod: 'Card',
          TransactionID: 'TXN987656789',
          Timestamp: '2023-04-02T11:00:00Z',
        },
        {
          PaymentID: 5,
          UserID: 5,
          Amount: 1575,
          PaymentMethod: 'UPI',
          TransactionID: 'TXN123454321',
          Timestamp: '2023-04-03T10:00:00Z',
        },
      ],
      Notes: [
        { NoteID: 1, Denomination: 200, Quantity: 50 },
        { NoteID: 2, Denomination: 100, Quantity: 100 },
        { NoteID: 3, Denomination: 50, Quantity: 150 },
        { NoteID: 4, Denomination: 20, Quantity: 200 },
        { NoteID: 5, Denomination: 10, Quantity: 250 },
      ],
      Sellers: [
        {
          SellerID: 1,
          Name: 'Aarav Patel',
          Notes: '200x10, 100x20, 50x40',
          Commission: 2,
        },
        {
          SellerID: 2,
          Name: 'Meera Gupta',
          Notes: '100x50, 20x100',
          Commission: 2.5,
        },
        {
          SellerID: 3,
          Name: 'Rohan Singh',
          Notes: '50x60, 10x200',
          Commission: 2.2,
        },
        {
          SellerID: 4,
          Name: 'Ishaan Krishnan',
          Notes: '200x5, 100x10, 50x20, 20x25',
          Commission: 2,
        },
        { SellerID: 5, Name: 'Priya Kumar', Notes: '10x500', Commission: 2.8 },
      ],
    };
    //Autogenerate multiple such calls ie for each resource and its data object
    let isSeeded = await this.IsSeeded();
    //if (!isSeeded) {
    //forcing app recreation
    if (true) {
      console.log('   Seeding database...');
      await this.SeedResource('UsersEntity', data.Users);
      await this.SeedResource('OrdersEntity', data.Orders);
      await this.SeedResource('PaymentsEntity', data.Payments);
      await this.SeedResource('NotesEntity', data.Notes);
      await this.SeedResource('SellersEntity', data.Sellers);
      await this.SeedResource('SettingsEntity', {
        settingname: 'isSeeded',
        settingvalue: 'true',
      });
    } else {
      console.log('   Database seeded already!');
    }
  }
  static async IsSeeded() {
    const repo = Database.ds.getRepository('SettingsEntity');
    let rec: any = await repo.findOne({
      select: {
        settingname: true,
        settingvalue: true,
      },
      where: {
        settingname: 'isSeeded',
      },
    });
    if (rec && rec.settingvalue) return true;
    return false;
  }
  static async SeedResource(resourceName: any, resourceData: any) {
    const repo = Database.ds.getRepository(resourceName);
    //await repo.clear();
    console.log('   Seeding table ' + resourceName);
    await repo.upsert(resourceData, ['id']);
  }
}
